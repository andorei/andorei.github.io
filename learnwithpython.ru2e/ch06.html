

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>6. Итерации &mdash; Учимся с Python</title>
    
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2nd Edition',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="top" title="Учимся с Python" href="index.html" />
    <link rel="next" title="7. Строки" href="ch07.html" />
    <link rel="prev" title="5. Функции, возвращающие значения" href="ch05.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Просмотр</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Словарь-указатель"
             accesskey="I">словарь</a></li>
        <li class="right" >
          <a href="ch07.html" title="7. Строки"
             accesskey="N">следующий</a> |</li>
        <li class="right" >
          <a href="ch05.html" title="5. Функции, возвращающие значения"
             accesskey="P">предыдущий</a> |</li>
        <li><a href="index.html">Учимся с Python</a> &raquo;</li> 
      </ul>
    </div>

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>6. Итерации<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h1>
<span class="target" id="index-0"></span><div class="section" id="index-1">
<span id="id2"></span><h2>6.1. Многократное присваивание<a class="headerlink" href="#index-1" title="Ссылка на этот заголовок">¶</a></h2>
<p>Как вы, наверное, уже заметили, многократное присваивание разных значений одной и той же переменной является совершенно обычным делом. Каждое новое присваивание связывает существующее имя переменной с новым значением (и отвязывает его от старого значения).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bruce</span> <span class="o">=</span> <span class="mi">5</span>
<span class="k">print</span> <span class="n">bruce</span><span class="p">,</span>
<span class="n">bruce</span> <span class="o">=</span> <span class="mi">7</span>
<span class="k">print</span> <span class="n">bruce</span>
</pre></div>
</div>
<p>Эта программа выводит <tt class="docutils literal"><span class="pre">5</span> <span class="pre">7</span></tt>, поскольку, когда переменная <tt class="docutils literal"><span class="pre">bruce</span></tt> выводится в первый раз, её значение равно 5, а когда во второй раз, переменная имеет значение 7. Запятая в конце первого предложения <tt class="docutils literal"><span class="pre">print</span></tt> подавляет перевод строки, вот почему оба числа выводятся на одной и той же строке.</p>
<p>Так выглядит <strong>многократное присваивание</strong> на диаграмме:</p>
<img alt="Многократное присваивание" src="_images/ch6-1.png" />
<p>Еще раз обратите внимание, как важно различать операцию присваивания и операцию сравнения. Поскольку для операции присваивания Python использует знак равенства <tt class="docutils literal"><span class="pre">=</span></tt>, возникает соблазн прочитать предложение, подобное <tt class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></tt>, как утверждение о равенстве. Но это будет ошибкой!</p>
<p>Утверждение о равенстве симметрично, а предложение присваивания &#8212; нет. Например, в математике, если a = 7, то 7 = a. Это же справедливо для логических выражений Python: если <tt class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">7</span></tt>, то и <tt class="docutils literal"><span class="pre">7</span> <span class="pre">==</span> <span class="pre">a</span></tt>. Но предложение присваивания <tt class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">7</span></tt> допустимо, а предложение <tt class="docutils literal"><span class="pre">7</span> <span class="pre">=</span> <span class="pre">a</span></tt> недопустимо.</p>
<p>В Python предложение присваивания может сделать две переменные равными, но они не обязаны оставаться равными всегда:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span>    <span class="c"># a и b сейчас равны</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>    <span class="c"># a и b больше не равны</span>
</pre></div>
</div>
<p>В третьей строке изменяется значение переменной <tt class="docutils literal"><span class="pre">a</span></tt>, но не изменяется значение переменной <tt class="docutils literal"><span class="pre">b</span></tt>, так что они больше не равны друг другу.</p>
<p>В некоторых языках программирования, чтобы избежать путаницы, для присваивания используется другой символ, например, <tt class="docutils literal"><span class="pre">&lt;-</span></tt> или <tt class="docutils literal"><span class="pre">:=</span></tt>.</p>
</div>
<div class="section" id="id3">
<h2>6.2. Обновление переменной<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h2>
<p>Часто новое значение, присваиваемое переменной, зависит от ее старого значения. Назовем такую форму повторного присваивания <em>обновлением переменной</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Это означает: взять текущее значение x, прибавить к нему один и присвоить полученное значение переменной x.</p>
<p>Если вы попытаетесь обновить несуществующую переменную, то получите ошибку, так как Python сначала вычисляет выражение справа от оператора присваивания, а затем присваивает полученное значение переменной слева:</p>
<div class="highlight-python"><pre>&gt;&gt;&gt; x = x + 1
Traceback (most recent call last):
  File "", line 1, in
NameError: name 'x' is not defined</pre>
</div>
<p>Прежде чем вы сможете обновить переменную, вы обязаны её <strong>инициализировать</strong> при помощи обычного присваивания:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Обновление переменной с прибавлением 1 к текущему значению называется <strong>инкрементом</strong>. Обновление с вычитанием 1 называется <strong>декрементом</strong>.</p>
<span class="target" id="index-2"></span></div>
<div class="section" id="while">
<span id="index-3"></span><h2>6.3. Предложение <tt class="docutils literal"><span class="pre">while</span></tt><a class="headerlink" href="#while" title="Ссылка на этот заголовок">¶</a></h2>
<p>Часто компьютеры используются для автоматизации повторяющихся задач. Повторение одних и тех же (или почти одних и тех же) действий &#8212; это то, с чем компьютеры справляются отлично, а люди посредственно.</p>
<p>Повторное выполнение одних и тех же предложений программы называют <strong>циклическим</strong> или <strong>итеративным</strong> выполнением. Так как итеративное выполнение очень часто встречаются в программировании, Python предоставляет несколько способов для его организации. Первый, который мы рассмотрим, &#8212; это предложение <tt class="docutils literal"><span class="pre">while</span></tt> (англ.: пока).</p>
<p>Функция <tt class="docutils literal"><span class="pre">countdown</span></tt> (англ.: обратный отсчет) демонстрирует использование предложения <tt class="docutils literal"><span class="pre">while</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">n</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">print</span> <span class="s">&quot;Go!&quot;</span>
</pre></div>
</div>
<p>Предложение <tt class="docutils literal"><span class="pre">while</span></tt> читается, как будто оно написано по-английски. Оно означает: пока <tt class="docutils literal"><span class="pre">n</span></tt> больше 0, продолжать выводить значение <tt class="docutils literal"><span class="pre">n</span></tt> и уменьшать <tt class="docutils literal"><span class="pre">n</span></tt> на 1. Когда значение <tt class="docutils literal"><span class="pre">n</span></tt> станет равным 0, будет выведено слово <tt class="docutils literal"><span class="pre">Go!</span></tt>.</p>
<p>Более формально поток выполнения предложения <tt class="docutils literal"><span class="pre">while</span></tt> выглядит так:</p>
<ol class="arabic simple">
<li>Проверить условие в заголовке <tt class="docutils literal"><span class="pre">while</span></tt>, получив <tt class="docutils literal"><span class="pre">True</span></tt> или <tt class="docutils literal"><span class="pre">False</span></tt>.</li>
<li>Если условие истинно, выполнить тело предложения <tt class="docutils literal"><span class="pre">while</span></tt> и вернуться к шагу 1.</li>
<li>Если условие ложно, завершить выполнение предложения <tt class="docutils literal"><span class="pre">while</span></tt> и продолжить
выполнение программы со следующего за ним предложения.</li>
</ol>
<p>Тело предложения <tt class="docutils literal"><span class="pre">while</span></tt> состоит из предложений, следующих за заголовком и имеющих одинаковый отступ относительно заголовка.</p>
<p>Теперь понятно, почему этот тип выполнения называется циклическим. Ведь со второго шага управление передается обратно на первый, замыкая цикл. Обратите внимание, что если условие цикла окажется ложным при первой же проверке, то тело цикла не выполнится ни разу.</p>
<p>Для того, чтобы условие в конце концов стало ложным и циклическое выполнение закончилось, в теле цикла одна или несколько переменных должны изменяться. Иначе цикл будет выполняться всегда, и мы получим <strong>бесконечный цикл</strong>. Программистов очень веселит следующая инструкция по применению шампуня: <em>Намылить, прополоскать, повторить</em>. Ведь это же бесконечный цикл!</p>
<p>Однократное выполнение тела цикла называется <strong>итерацией</strong>.</p>
<p>В случае функции <tt class="docutils literal"><span class="pre">countdown</span></tt> можно доказать, что цикл завершится, поскольку известно, что значение <tt class="docutils literal"><span class="pre">n</span></tt> конечно, и мы видим, что оно становится меньше с каждой итерацией, так что в конце концов станет равным 0. В других случаях не все так просто:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">sequence</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">n</span><span class="p">,</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>        <span class="c"># n is even</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>                 <span class="c"># n is odd</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Условие для этого цикла <tt class="docutils literal"><span class="pre">n</span> <span class="pre">!=</span> <span class="pre">1</span></tt>, поэтому цикл будет выполняться до тех пор, пока <tt class="docutils literal"><span class="pre">n</span></tt> не станет равным <tt class="docutils literal"><span class="pre">1</span></tt> (что сделает условие ложным).</p>
<p>В каждой итерации программа выводит значение <tt class="docutils literal"><span class="pre">n</span></tt> и затем проверят, является оно четным или нечетным. Если значение <tt class="docutils literal"><span class="pre">n</span></tt> четно, то оно делится на 2. Если нечетно, то делается равным <tt class="docutils literal"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">3</span> <span class="pre">+</span> <span class="pre">1</span></tt>. Например, если начальное значение (аргумент, переданный функции sequence) равно 3, то получим последовательность 3, 10, 5, 16, 8, 4, 2, 1.</p>
<p>Так как <tt class="docutils literal"><span class="pre">n</span></tt> иногда увеличивается, а иногда уменьшается, мы не видим очевидного доказательства того, что <tt class="docutils literal"><span class="pre">n</span></tt> когда-либо станет равным 1 и программа завершится. Для некоторых конкретных значений <tt class="docutils literal"><span class="pre">n</span></tt> можно доказать, что программа завершится. Например, если начальное значение есть степень двойки, то значение <tt class="docutils literal"><span class="pre">n</span></tt> будет четным в каждой итерации, пока не достигнет значения 1. Последовательность, приведенная в качестве примера выше, заканчивается именно такой последовательностью, начиная с 16.</p>
<p>Оставляя в стороне конкретные значения, представляет интерес вопрос о том, можно ли доказать, что программа завершится при любом значении <tt class="docutils literal"><span class="pre">n</span></tt>? До сих пор никому не удалось ни доказать это, ни опровергнуть!</p>
</div>
<div class="section" id="index-4">
<span id="id4"></span><h2>6.4. Трассировка программы<a class="headerlink" href="#index-4" title="Ссылка на этот заголовок">¶</a></h2>
<p>Для того, чтобы писать эффективные компьютерные программы, разработчику необходимо выработать навык <strong>трассировки</strong> программ. Трассировка требует от программиста играть роль компьютера и следовать потоку выполнения программы, записывая состояние всех переменных и вывод, который производит программа, после каждой выполненной инструкции.</p>
<p>Чтобы понять этот процесс, давайте оттрассируем вызов <tt class="docutils literal"><span class="pre">sequence(3)</span></tt> из предыдущего раздела. В начале трассировки, у нас есть локальная переменная <tt class="docutils literal"><span class="pre">n</span></tt> (параметр) с начальным значением 3. Так как 3 не равно 1, выполняется тело цикла <tt class="docutils literal"><span class="pre">while</span></tt>. На экран выводится 3 и вычисляется выражение <tt class="docutils literal"><span class="pre">3</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0</span></tt>. Поскольку это выражение дает <tt class="docutils literal"><span class="pre">False</span></tt>, то выполняется ветка <tt class="docutils literal"><span class="pre">else</span></tt>, то есть, вычисляется <tt class="docutils literal"><span class="pre">3</span> <span class="pre">*</span> <span class="pre">3</span> <span class="pre">+</span> <span class="pre">1</span></tt> и результат присваивается <tt class="docutils literal"><span class="pre">n</span></tt>.</p>
<p>Чтобы во время трассировки программы вручную отслеживать происходящее, сделайте на листке бумаги по столбцу на каждую используемую переменную, и еще один &#8212; для вывода программы. К этому моменту мы имеем:</p>
<div class="highlight-python"><pre>n               output
--              ------
3               3
10</pre>
</div>
<p>Так как выражение <tt class="docutils literal"><span class="pre">10</span> <span class="pre">!=</span> <span class="pre">1</span></tt> дает <tt class="docutils literal"><span class="pre">True</span></tt>, то тело цикла выполняется вновь, и выводится 10. Выражение <tt class="docutils literal"><span class="pre">10</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0</span></tt> истинно, поэтому выполняется ветка <tt class="docutils literal"><span class="pre">if</span></tt> и значение <tt class="docutils literal"><span class="pre">n</span></tt> становится равным 5. Оттрассировав программу до конца, мы получим:</p>
<div class="highlight-python"><pre>n               output
--              ------
3               3
10              10
5               5
16              16
8               8
4               4
2               2
1</pre>
</div>
<p>Трассировка может быть слегка утомительным занятием, и чревата ошибками (вот почему люди научили компьютеры выполнять трассировку!), но это один из основных навыков программиста. Выполнив трассировку, можно многое узнать о том, как работает программа. Можно заметить, например, что, как только n получает значение степени двойки, программе требуется log<sub>2</sub>(n) итераций для завершения. Мы также видим, что конечная 1 не выводится.</p>
</div>
<div class="section" id="counting">
<span id="id5"></span><h2>6.5. Считаем цифры<a class="headerlink" href="#counting" title="Ссылка на этот заголовок">¶</a></h2>
<p>Вы, конечно, знаете разницу между числами и цифрами? Цифры &#8212; это символы, с помощью которых записывают числа (аналогично тому, как с помощью букв записывают слова). Так, при помощи десяти цифр 0, 1, 2, 3, 4, 5, 6, 7, 8 и 9 можно записать любое целое положительное число в десятичном представлении.</p>
<p>Следующая функция подсчитывает количество цифр в десятичном представлении числа, переданного ей в качестве параметра:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">num_digits</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">10</span>
    <span class="k">return</span> <span class="n">count</span>
</pre></div>
</div>
<p>Вызов <tt class="docutils literal"><span class="pre">num_digits(710)</span></tt> вернет <tt class="docutils literal"><span class="pre">3</span></tt>. Оттрассируйте выполнение этой функции для того, чтобы детально разобраться, как именно она работает.</p>
<p>Эта функция демонстрирует прием программирования, который называется <strong>счетчик</strong>. Переменная <tt class="docutils literal"><span class="pre">count</span></tt> (англ.: счетчик) инициализируется нулем и затем инкрементируется каждый раз, когда выполняется тело цикла. Когда цикл завершается, <tt class="docutils literal"><span class="pre">count</span></tt> содержит число, показывающее, сколько раз выполнилось тело цикла. Это и будет искомое количество цифр в десятичном представлении <tt class="docutils literal"><span class="pre">n</span></tt>.</p>
<p>Если бы мы хотели подсчитать только количество нулей или пятерок, то решили бы эту задачу, сделав увеличение счетчика условным:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">num_zero_and_five_digits</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">digit</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">10</span>
        <span class="k">if</span> <span class="n">digit</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">digit</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">10</span>
    <span class="k">return</span> <span class="n">count</span>
</pre></div>
</div>
<p>Убедитесь, что <tt class="docutils literal"><span class="pre">num_zero_and_five_digits(1055030250)</span></tt> возвращает 7.</p>
</div>
<div class="section" id="id6">
<h2>6.6. Краткая форма записи обновления<a class="headerlink" href="#id6" title="Ссылка на этот заголовок">¶</a></h2>
<p>Инкрементирование переменной так часто встречается, что Python предлагает для подобных случаев краткую форму записи:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span>
<span class="go">2</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Предложение <tt class="docutils literal"><span class="pre">count</span> <span class="pre">+=</span> <span class="pre">1</span></tt> есть краткая форма предложения <tt class="docutils literal"><span class="pre">count</span> <span class="pre">=</span> <span class="pre">count</span> <span class="pre">+</span> <span class="pre">1</span></tt> . Значение инкремента не обязано быть равным 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">+=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span>
<span class="go">7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Также существуют следующие символы, комбинирующие выполнение арифметической операции и присваивание: <tt class="docutils literal"><span class="pre">-=</span></tt>, <tt class="docutils literal"><span class="pre">*=</span></tt>, <tt class="docutils literal"><span class="pre">/=</span></tt> и <tt class="docutils literal"><span class="pre">%=</span></tt>. Следующий пример демонстрирует их использование:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">*=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">-=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">/=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">%=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span>
<span class="go">1</span>
</pre></div>
</div>
</div>
<div class="section" id="index-5">
<span id="id7"></span><h2>6.7. Таблицы<a class="headerlink" href="#index-5" title="Ссылка на этот заголовок">¶</a></h2>
<p>Циклы хорошо подходят для такой работы, как порождение табличных данных. До того, как компьютеры стали общедоступны, людям приходилось вручную расчитывать логарифмы, синусы и косинусы, а также другие математические функции. Для облегчения расчетов математические справочники содержали длинные таблицы со значениями этих функций. Создание этих таблиц было медленным и утомительным, и в них порой закрадывались ошибки.</p>
<p>Когда на сцене появились компьютеры, одной из первых реакций на это было: &#8220;Здорово! Мы сможем генерировать таблицы с помощью компьютеров, так что в них не будет ошибок!&#8221; Реакция, по сути, правильная, но недальновидная. Вскоре компьютеры и калькуляторы так распространились, что таблицы вышли из употребления.</p>
<p>Ну, почти вышли. При выполнении некоторых операций компьютеры используют таблицы значений, чтобы получить приблизительный результат, а затем уточняют его при помощи дальнейших вычислений. Бывали случаи, когда во внутренних таблицах встречались ошибки, наиболее известная из них &#8212; ошибка в таблице процессора Intel Pentium для выполнения деления чисел с плавающей точкой.</p>
<p>Хотя таблица логарифмов сегодня не так полезна, как была когда-то, она представляет собой отличный пример использования итераций. Следующая программа выводит последовательность значений в левом столбце и соответствующих степеней двойки в правом:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">13</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">x</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">x</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Строка <tt class="docutils literal"><span class="pre">'\t'</span></tt> задает символ <strong>табуляции</strong>. Обратная косая в <tt class="docutils literal"><span class="pre">'\t'</span></tt> показывает начало <strong>управляющей последовательности</strong>. Управляющие последовательности используются для задания невидимых символов, например, таких, как табуляция и перевод строки. Последовательность <tt class="docutils literal"><span class="pre">'\n'</span></tt> задает <strong>перевод строки</strong>.</p>
<p>Управляющая последовательность может появляться в любом месте строки; в нашем примере, управляющая последовательность <tt class="docutils literal"><span class="pre">'\t'</span></tt> &#8212; это все, что есть в строке. Как вы думаете, как можно задать обратную косую в строке?</p>
<p>По мере того, как на экране отображаются символы и строки, невидимый указатель, называемый <strong>курсор</strong>, указывает место, где будет отображен следующий символ. После выполнения предложения <tt class="docutils literal"><span class="pre">print</span></tt> курсор обычно оказывается в начале следующей строки.</p>
<p>Символ табуляции перемещает курсор на следующую позицию табуляции. Табуляция полезна для выравнивания столбцов текста, как, например, в выводе нашей программы:</p>
<div class="highlight-python"><pre>1       2
2       4
3       8
4       16
5       32
6       64
7       128
8       256
9       512
10      1024
11      2048
12      4096</pre>
</div>
<p>Благодаря символам табуляции между столбцами, позиция, в которой начинается второй столбец, не зависит от количества цифр в первом столбце.</p>
</div>
<div class="section" id="id8">
<h2>6.8. Двумерные таблицы<a class="headerlink" href="#id8" title="Ссылка на этот заголовок">¶</a></h2>
<p>Двумерные таблицы &#8212; это таблицы, в которых интересующее вас значение находится на пересечении строки и столбца. Хорошим примером является таблица умножения. Скажем, вы хотите напечатать таблицу умножения для значений от 1 до 6.</p>
<p>Для начала, напишем цикл, который печатает числа, кратные 2, на одной строке:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">:</span>
    <span class="k">print</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="s">&#39;   &#39;</span><span class="p">,</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">print</span>
</pre></div>
</div>
<p>В первой строке инициализируется переменная <tt class="docutils literal"><span class="pre">i</span></tt>, которая выполняет роль счетчика или <strong>переменной цикла</strong>. По мере того, как цикл выполняется, значение <tt class="docutils literal"><span class="pre">i</span></tt> увеличивается от 1 до 6. Когда <tt class="docutils literal"><span class="pre">i</span></tt> становится равным 7, цикл завершается. В каждой итерации отображается значение <tt class="docutils literal"><span class="pre">2*i</span></tt> и три пробела.</p>
<p>Помните, что запятая в конце предложения <tt class="docutils literal"><span class="pre">print</span></tt> подавляет перевод строки? После того, как цикл завершается, второе предложение <tt class="docutils literal"><span class="pre">print</span></tt> начинает новую строку.</p>
<p>Программа выводит следующее:</p>
<div class="highlight-python"><pre>2      4      6      8      10     12</pre>
</div>
<p>Пока все замечательно. Следующим шагом будет <strong>инкапсуляция</strong> и <strong>обобщение</strong>.</p>
</div>
<div class="section" id="index-6">
<span id="id9"></span><h2>6.9. Обобщение<a class="headerlink" href="#index-6" title="Ссылка на этот заголовок">¶</a></h2>
<p>Оформив полезный фрагмент кода как функцию, мы можем использовать этот код многократно, вызывая функцию там, где это необходимо. Мы уже дважды <em>заворачивали</em> наш код в функции : <tt class="docutils literal"><span class="pre">print_parity</span></tt> в главе 4 и <tt class="docutils literal"><span class="pre">is_divisible</span></tt> в главе 5. Часто, создавая новую функцию, программисты используют обобщение.</p>
<p>Обобщение означает взять что-нибудь конкретное, например, вывод на печать чисел, кратных 2, и сделать из этого что-то более общее, например, печать чисел, кратных любому целому числу.</p>
<p>Следующая функция использует рассмотренный выше цикл, обобщенный для вывода чисел, кратных <tt class="docutils literal"><span class="pre">n</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">print_multiples</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">n</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">,</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">print</span>
</pre></div>
</div>
<p>Все, что нам понадобилось для превращения кода в функцию &#8212; это добавить первую строку, которая объявляет имя функции и список параметров. Все, что понадобилось для обобщения, &#8212; заменить значение 2 на параметр <tt class="docutils literal"><span class="pre">n</span></tt>.</p>
<p>Если вызвать эту функцию с аргументом 2, то получим тот же вывод, что и раньше. С аргументом 3 вывод будет таким:</p>
<div class="highlight-python"><pre>3      6      9      12     15     18</pre>
</div>
<p>С аргументом 4 &#8212; таким:</p>
<div class="highlight-python"><pre>4      8      12     16     20     24</pre>
</div>
<p>Вы уже, наверное, догадались, как напечатать таблицу умножения &#8212; многократно вызывая <tt class="docutils literal"><span class="pre">print_multiples</span></tt> с разными аргументами. Можно воспользоваться еще одним циклом:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">:</span>
    <span class="n">print_multiples</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Заметьте, как похож этот цикл на первый, в теле функции <tt class="docutils literal"><span class="pre">print_multiples</span></tt>. Все, что мы сделали &#8212; это заменили предложение <tt class="docutils literal"><span class="pre">print</span></tt> на вызов функции.</p>
<p>Эта программа выводит таблицу умножения:</p>
<div class="highlight-python"><pre>1      2      3      4      5      6
2      4      6      8      10     12
3      6      9      12     15     18
4      8      12     16     20     24
5      10     15     20     25     30
6      12     18     24     30     36</pre>
</div>
</div>
<div class="section" id="id10">
<h2>6.10. Снова создание функции<a class="headerlink" href="#id10" title="Ссылка на этот заголовок">¶</a></h2>
<p>Возьмем код из предыдущего раздела и завернем его в функцию:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">print_mult_table</span><span class="p">():</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">:</span>
        <span class="n">print_multiples</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Это довольно распространенный подход к разработке. Вначале пишем код, создавая строки кода вне функции или набирая их в интерактивном режиме интерпретатора. Когда код заработает, заворачиваем его в функцию.</p>
<p>Этот подход особенно полезен, если в начале работы над программой вы не уверены, как наилучшим образом разделить программу на функции. Он позволяет определять и улучшать структуру программы по мере того, как вы продвигаетесь вперед.</p>
</div>
<div class="section" id="index-7">
<span id="id11"></span><h2>6.11. Локальные переменные<a class="headerlink" href="#index-7" title="Ссылка на этот заголовок">¶</a></h2>
<p>Возможно, вас удивляет, что мы используем переменную <tt class="docutils literal"><span class="pre">i</span></tt> и в <tt class="docutils literal"><span class="pre">print_multiples</span></tt> и в <tt class="docutils literal"><span class="pre">print_mult_table</span></tt>. Не возникнут ли проблемы, когда одна из этих функций изменит значение переменной?</p>
<p>Ответ: нет, потому что <tt class="docutils literal"><span class="pre">i</span></tt> в <tt class="docutils literal"><span class="pre">print_multiples</span></tt> и <tt class="docutils literal"><span class="pre">i</span></tt> в <tt class="docutils literal"><span class="pre">print_mult_table</span></tt> &#8212; не одна и та же переменная.</p>
<p>Переменные, созданные внутри определения функции, являются локальными. Нельзя получить доступ к такой переменной вне функции, в которой она определена. Это означает, что в программе может быть множество переменных с одним и тем же именем при условии, что они не находятся внутри одной и той же функции.</p>
<p>Стековая диаграмма для этой программы показывает, что две переменные с именем <tt class="docutils literal"><span class="pre">i</span></tt> &#8212; не одна и та же переменная. Они могут быть связаны с разными значениями, и изменение одной из них не влияет на другую.</p>
<img alt="Стековая диаграмма" src="_images/ch6-2.png" />
<p>Значение переменной <tt class="docutils literal"><span class="pre">i</span></tt> в <tt class="docutils literal"><span class="pre">print_mult_table</span></tt> изменяется от 1 до 6. На диаграмме она имеет значение 3. В следующей итерации ее значением будет 4. Каждый раз при выполнении тела цикла <tt class="docutils literal"><span class="pre">print_mult_table</span></tt> вызывает <tt class="docutils literal"><span class="pre">print_multiples</span></tt> с текущим значением <tt class="docutils literal"><span class="pre">i</span></tt> в качестве аргумента. Это значение присваивается параметру <tt class="docutils literal"><span class="pre">n</span></tt>.</p>
<p>Внутри <tt class="docutils literal"><span class="pre">print_multiples</span></tt> значение <tt class="docutils literal"><span class="pre">i</span></tt> изменяется от 1 до 6. На диаграмме значение этой переменной равно 2. Изменение этой переменной не оказывает никакого влияния на значение переменной <tt class="docutils literal"><span class="pre">i</span></tt> в <tt class="docutils literal"><span class="pre">print_mult_table</span></tt>.</p>
<p>Различные локальные переменные с одним и тем же именем часто встречаются, и в этом нет ничего необычного. В частности, такие имена как <tt class="docutils literal"><span class="pre">i</span></tt> или <tt class="docutils literal"><span class="pre">j</span></tt> часто используются как переменные цикла.</p>
</div>
<div class="section" id="id12">
<h2>6.12. Еще раз обобщение<a class="headerlink" href="#id12" title="Ссылка на этот заголовок">¶</a></h2>
<p>Как другой пример обобщения, представьте, что вам нужна программа, которая бы печатала таблицу умножения любого размера, а не только 6 на 6. Можно добавить параметр к <tt class="docutils literal"><span class="pre">print_mult_table</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">print_mult_table</span><span class="p">(</span><span class="n">high</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">:</span>
        <span class="n">print_multiples</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Мы заменили значение 6 параметром <tt class="docutils literal"><span class="pre">high</span></tt>. Если теперь вызвать <tt class="docutils literal"><span class="pre">print_mult_table</span></tt> с аргументом 7, вывод программы будет таким:</p>
<div class="highlight-python"><pre>1      2      3      4      5      6
2      4      6      8      10     12
3      6      9      12     15     18
4      8      12     16     20     24
5      10     15     20     25     30
6      12     18     24     30     36
7      14     21     28     35     42</pre>
</div>
<p>Замечательно, вот только хотелось бы, чтобы таблица была квадратной &#8212; с одинаковым числом строк и столбцов. Чтобы этого добиться, добавим еще один параметр к <tt class="docutils literal"><span class="pre">print_multiples</span></tt>, задающий количество столбцов.</p>
<p>Нарочно назовем этот параметр <tt class="docutils literal"><span class="pre">high</span></tt>, демонстрируя, что разные функции могут иметь параметры с одинаковыми именами (так же, как они могут иметь одноименные локальные переменные). Вот программа целиком:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">print_multiples</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">high</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">n</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">,</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">print</span>

<span class="k">def</span> <span class="nf">print_mult_table</span><span class="p">(</span><span class="n">high</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">:</span>
        <span class="n">print_multiples</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Обратите внимание, что, когда мы добавили новый параметр, нам пришлось изменить первую строку функции (заголовок функции) и вызов функции в <tt class="docutils literal"><span class="pre">print_mult_table</span></tt>.</p>
<p>Теперь программа выводит квадратную таблицу 7 на 7:</p>
<div class="highlight-python"><pre>1      2      3      4      5      6      7
2      4      6      8      10     12     14
3      6      9      12     15     18     21
4      8      12     16     20     24     28
5      10     15     20     25     30     35
6      12     18     24     30     36     42
7      14     21     28     35     42     49</pre>
</div>
<p>Правильно выполненное обобщение функции часто открывает возможности, которые не планировались с самого начала. Например, как вы наверняка заметили, поскольку ab = ba, все произведения в таблице появляются дважды. Можно сэкономить чернила, печатая только половину таблицы. Для этого достаточно изменить одну строку функции <tt class="docutils literal"><span class="pre">print_mult_table</span></tt>. Изменим</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">print_multiples</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
</pre></div>
</div>
<p>на</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">print_multiples</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>и получим:</p>
<div class="highlight-python"><pre>1
2      4
3      6      9
4      8      12     16
5      10     15     20     25
6      12     18     24     30     36
7      14     21     28     35     42     49</pre>
</div>
</div>
<div class="section" id="index-8">
<span id="id13"></span><h2>6.13. Функции<a class="headerlink" href="#index-8" title="Ссылка на этот заголовок">¶</a></h2>
<p>Мы уже пару раз упоминали о преимуществах, которые дает использование функций. Вот некоторые из этих преимуществ:</p>
<ol class="arabic simple">
<li>Давая имя последовательности предложений, мы делаем программу легче для
чтения и отладки.</li>
<li>Разбиение большой программы на функции позволяет отделить части программы
друг от друга, отладить их по отдельности, а затем собрать их в одно целое.</li>
<li>Хорошо спроектированные функции часто полезны для многих программ. Написав
такую функцию, можно использовать ее неоднократно.</li>
</ol>
</div>
<div class="section" id="index-9">
<span id="id14"></span><h2>6.14. Метод Ньютона<a class="headerlink" href="#index-9" title="Ссылка на этот заголовок">¶</a></h2>
<p>Циклы часто используются в программах, выполняющих численные расчеты, когда вначале берется приблизительный ответ, а затем это приближение итеративно улучшается.</p>
<p>Например, один из способов вычисления квадратных корней &#8212; метод Ньютона. Предположим, вы хотите получить квадратный корень из <tt class="docutils literal"><span class="pre">n</span></tt>. Если начать с какого угодно приближения, то можно посчитать лучшее приближение по следующей формуле:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">better</span> <span class="o">=</span>  <span class="p">(</span><span class="n">approx</span> <span class="o">+</span> <span class="n">n</span><span class="o">/</span><span class="n">approx</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
</pre></div>
</div>
<p>Напишем функцию для вычисления квадратного корня, многократно применяя эту формулу до тех пор, пока улучшенное приближение не окажется равным предыдущему:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">approx</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mf">2.0</span>
    <span class="n">better</span> <span class="o">=</span> <span class="p">(</span><span class="n">approx</span> <span class="o">+</span> <span class="n">n</span><span class="o">/</span><span class="n">approx</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
    <span class="k">while</span> <span class="n">better</span> <span class="o">!=</span> <span class="n">approx</span><span class="p">:</span>
        <span class="n">approx</span> <span class="o">=</span> <span class="n">better</span>
        <span class="n">better</span> <span class="o">=</span> <span class="p">(</span><span class="n">approx</span> <span class="o">+</span> <span class="n">n</span><span class="o">/</span><span class="n">approx</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
    <span class="k">return</span> <span class="n">approx</span>
</pre></div>
</div>
<p>Попробуйте вызвать эту функцию с аргументом <tt class="docutils literal"><span class="pre">25</span></tt> и убедитесь, что она возвращает <tt class="docutils literal"><span class="pre">5.0</span></tt>.</p>
</div>
<div class="section" id="index-10">
<span id="id15"></span><h2>6.15. Алгоритмы<a class="headerlink" href="#index-10" title="Ссылка на этот заголовок">¶</a></h2>
<p>Метод Ньютона является примером <strong>алгоритма</strong>: это формальный процесс решения некоторого класса задач (в данном случае, вычисление квадратных корней).</p>
<p>Разработать алгоритм непросто. Иногда проще начать с чего-то, что не является алгоритмом. Когда вы учились умножать однозначные числа, вы, вероятно, запомнили таблицу умножения. По сути, вы запомнили 100 конкретных результатов. Такой тип знания не является алгоритмическим.</p>
<p>Но если вам было немного лень, вы жульничали, научившись нескольким хитростям. Например, чтобы найти произведение n и 9, можно записать n - 1 в качестве первой цифры и 10 - n в качестве второй цифры. Этот трюк &#8212; общее решение для умножения любого однозначного числа на 9. Это алгоритм!</p>
<p>Аналогично, приемы, которые вы изучили для сложения с переносом, вычитания с заемом и деления многозначных чисел &#8212; все это алгоритмы. Характерной чертой алгоритмов является то, что для их выполнения не нужен интеллект. Это чисто механические процессы, в которых следующий шаг вытекает из предыдущего согласно простому набору правил.</p>
<p>Не странно ли, что люди тратят так много времени в школе на то, чтобы научиться выполнять алгоритмы? Ведь это совершенно не требует ума.</p>
<p>В отличие от применения алгоритмов, их разработка &#8212; интересный, интеллектуально насыщенный процесс, и неотъемлемая часть программирования.</p>
<p>Многие действия, которые люди выполняют естественно, без труда или сознательного обдумывания, очень сложно выразить в виде алгоритмов. К таким действиям относится, например, понимание естественного языка. Все мы делаем это, но до сих пор никто не смог в форме алгоритма объяснить, <em>как</em> мы это делаем.</p>
</div>
<div class="section" id="id16">
<h2>6.16. Глоссарий<a class="headerlink" href="#id16" title="Ссылка на этот заголовок">¶</a></h2>
<dl class="glossary docutils">
<dt id="term-">алгоритм</dt>
<dd>Пошаговый процесс решения некоторого класса задач.</dd>
<dt id="term-1">бесконечный цикл</dt>
<dd>Цикл, в котором условие завершения никогда не наступит.</dd>
<dt id="term-2">декремент</dt>
<dd>Уменьшение на 1.</dd>
<dt id="term-3">инициализация переменной</dt>
<dd>Присваивание переменной начального значения. Поскольку в Python
переменные не существуют, пока им не присвоено значение,
они инициализируются в момент создания. В других языках программирования
это не так, и переменные могут создаваться без инициализации, получая
в этом случае либо значение по умолчанию либо неопределенное
значение (мусор).</dd>
<dt id="term-4">инкремент</dt>
<dd>Увеличение на 1.</dd>
<dt id="term-5">итеративное выполнение</dt>
<dd>Повторяемое выполнение последовательности предложений языка программирования.</dd>
<dt id="term-6">итерация</dt>
<dd>Однократное выполнение тела цикла.</dd>
<dt id="term-7">курсор</dt>
<dd>Невидимый указатель, указывающий, куда будет выведен следующий символ.</dd>
<dt id="term-8">многократное присваивание</dt>
<dd>Выполнение более одного присваивания одной и той же переменной в ходе
выполнения программы.</dd>
<dt id="term-9">обобщение</dt>
<dd>Замена чего-либо конкретного (например, значение) на более общее
(например, переменная или параметр). Обобщение делает код более
универсальным, облегчает его повторное использование, а иногда и его
создание.</dd>
<dt id="term-10">перевод строки</dt>
<dd>Специальный символ, заставляющий курсор перемещаться в начало следующей
строки.</dd>
<dt id="term-11">переменная цикла</dt>
<dd>Переменная, используемая в условии завершения цикла.</dd>
<dt id="term-12">процесс разработки</dt>
<dd>Деятельность по созданию программы, включающая ряд приемов и практик,
нацеленных на эффективное создание качественных программ. Вы уже
познакомились с такими приемами и практиками, как
модульное тестирование, инкрементная разработка, отладка, трассировка
и обобщением.</dd>
<dt id="term-13">счетчик</dt>
<dd>Переменная, используемая для подсчета чего-либо. Обычно инициализируется
нулем и инкрементируется в теле цикла.</dd>
<dt id="term-14">табуляция</dt>
<dd>Специальный символ, заставляющий курсор перемещаться на следующую
позицию табуляции в текущей строке.</dd>
<dt id="term-15">тело цикла</dt>
<dd>Многократно выполняемая последовательность предложений. Размещается
внутри составного предложения, организующего циклическое выполнение.</dd>
<dt id="term-16">трассировка программы</dt>
<dd>Следование потоку выполнения программы, с записью изменений
состояния переменных и вывода программы.</dd>
<dt id="term-17">управляющая последовательность</dt>
<dd>Обратная косая <tt class="docutils literal"><span class="pre">\</span></tt>, за которой следует один или более печатный символ.
Используется для задания непечатаемых символов.</dd>
<dt id="term-18">цикл</dt>
<dd>Предложение или группа предложений, выполняемая многократно до тех пор,
пока не наступит условие завершения цикла.</dd>
<dt id="term-19">циклическое выполнение</dt>
<dd>То же, что итеративное выполнение.</dd>
</dl>
</div>
<div class="section" id="id17">
<h2>6.17. Упражнения<a class="headerlink" href="#id17" title="Ссылка на этот заголовок">¶</a></h2>
<ol class="arabic">
<li><p class="first">Напишите однострочное предложение, которое выводит:</p>
<div class="highlight-python"><pre>produces
this
output.</pre>
</div>
</li>
<li><p class="first">Добавьте предложение print к функции <tt class="docutils literal"><span class="pre">sqrt</span></tt> из раздела 6.14, которое выводит
<tt class="docutils literal"><span class="pre">better</span></tt> в каждой итерации. Вызовите измененную функцию с аргументом 25 и
рассмотрите результат выполнения.</p>
</li>
<li><p class="first">Оттрассируйте выполнение последней версии <tt class="docutils literal"><span class="pre">print_mult_table</span></tt> и разберитесь,
как она работает.</p>
</li>
<li><p class="first">Напишите функцию <tt class="docutils literal"><span class="pre">print_triangular_numbers(n)</span></tt>, которая выводит первые n
треугольных чисел. Вызов <tt class="docutils literal"><span class="pre">print_triangular_numbers(5)</span></tt> должен вывести
следующее:</p>
<div class="highlight-python"><pre>1       1
2       3
3       6
4       10
5       15</pre>
</div>
<p>Подсказка: воспользуйтесь поиском в интернет чтобы выяснить, что такое
треугольные числа.</p>
</li>
<li><p class="first">Откройте файл с именем <tt class="docutils literal"><span class="pre">ch06.py</span></tt> и добавьте следующее:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>
</div>
<p>Напишите функцию <tt class="docutils literal"><span class="pre">is_prime</span></tt> которая принимает один целочисленный аргумент
и возвращает <tt class="docutils literal"><span class="pre">True</span></tt>, если аргумент является простым числом, и <tt class="docutils literal"><span class="pre">False</span></tt> в
противном случае. Начните работу с написания доктестов для этой функции.</p>
</li>
<li><p class="first">Что вернет <tt class="docutils literal"><span class="pre">num_digits(0)</span></tt>? Измените функцию так, чтобы она возвращала
<tt class="docutils literal"><span class="pre">1</span></tt> для этого случая. Почему вызов <tt class="docutils literal"><span class="pre">num_digits(-24)</span></tt> приводит к бесконечному
циклу? Измените <tt class="docutils literal"><span class="pre">num_digits</span></tt> так, чтобы она
работала корректно с любым целым числом.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">num_digits</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      &gt;&gt;&gt; num_digits(12345)</span>
<span class="sd">      5</span>
<span class="sd">      &gt;&gt;&gt; num_digits(0)</span>
<span class="sd">      1</span>
<span class="sd">      &gt;&gt;&gt; num_digits(-12345)</span>
<span class="sd">      5</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Допишите тело функции <tt class="docutils literal"><span class="pre">num_digits</span></tt> и убедитесь, что все доктесты успешно
проходят.</p>
</li>
<li><p class="first">Добавьте следующее в файл <tt class="docutils literal"><span class="pre">ch06.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">num_even_digits</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      &gt;&gt;&gt; num_even_digits(123456)</span>
<span class="sd">      3</span>
<span class="sd">      &gt;&gt;&gt; num_even_digits(2468)</span>
<span class="sd">      4</span>
<span class="sd">      &gt;&gt;&gt; num_even_digits(1357)</span>
<span class="sd">      0</span>
<span class="sd">      &gt;&gt;&gt; num_even_digits(2)</span>
<span class="sd">      1</span>
<span class="sd">      &gt;&gt;&gt; num_even_digits(20)</span>
<span class="sd">      2</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Напишите тело функции <tt class="docutils literal"><span class="pre">num_even_digits</span></tt> (англ.: число четных цифр) так,
чтобы она работала корректно.</p>
</li>
<li><p class="first">Добавьте следующее в файл <tt class="docutils literal"><span class="pre">ch06.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">print_digits</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      &gt;&gt;&gt; print_digits(13789)</span>
<span class="sd">      9 8 7 3 1</span>
<span class="sd">      &gt;&gt;&gt; print_digits(39874613)</span>
<span class="sd">      3 1 6 4 7 8 9 3</span>
<span class="sd">      &gt;&gt;&gt; print_digits(213141)</span>
<span class="sd">      1 4 1 3 1 2</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Напишите тело функции <tt class="docutils literal"><span class="pre">print_digits</span></tt> так, чтобы все доктесты успешно прошли.</p>
</li>
<li><p class="first">Напишите функцию <tt class="docutils literal"><span class="pre">sum_of_squares_of_digits</span></tt>, которая вычисляет сумму
квадратов цифр целого числа, переданного в качестве аргумента. Например,
<tt class="docutils literal"><span class="pre">sum_of_squares_of_digits(987)</span></tt> должно дать 194, так как
<tt class="docutils literal"><span class="pre">9**2</span> <span class="pre">+</span> <span class="pre">8**2</span> <span class="pre">+</span> <span class="pre">7**2</span> <span class="pre">==</span> <span class="pre">81</span> <span class="pre">+</span> <span class="pre">64</span> <span class="pre">+</span> <span class="pre">49</span> <span class="pre">==</span> <span class="pre">194</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">sum_of_squares_of_digits</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      &gt;&gt;&gt; sum_of_squares_of_digits(1)</span>
<span class="sd">      1</span>
<span class="sd">      &gt;&gt;&gt; sum_of_squares_of_digits(9)</span>
<span class="sd">      81</span>
<span class="sd">      &gt;&gt;&gt; sum_of_squares_of_digits(11)</span>
<span class="sd">      2</span>
<span class="sd">      &gt;&gt;&gt; sum_of_squares_of_digits(121)</span>
<span class="sd">      6</span>
<span class="sd">      &gt;&gt;&gt; sum_of_squares_of_digits(987)</span>
<span class="sd">      194</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Проверьте ваше решение с помощью приведенных доктестов.</p>
</li>
</ol>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Просмотр</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Словарь-указатель"
             >словарь</a></li>
        <li class="right" >
          <a href="ch07.html" title="7. Строки"
             >следующий</a> |</li>
        <li class="right" >
          <a href="ch05.html" title="5. Функции, возвращающие значения"
             >предыдущий</a> |</li>
        <li><a href="index.html">Учимся с Python</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="copyright.html">Copyright</a> 2009, 2012, Джеффри Элкнер, Аллен Б. Дауни, Крис Мейерс, Андрей Трофимов.
      При создании использован <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>