

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>14. Коллекции объектов &mdash; Учимся с Python</title>
    
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2nd Edition',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="top" title="Учимся с Python" href="index.html" />
    <link rel="next" title="15. Наследование" href="ch15.html" />
    <link rel="prev" title="13. Методы" href="ch13.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Просмотр</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Словарь-указатель"
             accesskey="I">словарь</a></li>
        <li class="right" >
          <a href="ch15.html" title="15. Наследование"
             accesskey="N">следующий</a> |</li>
        <li class="right" >
          <a href="ch13.html" title="13. Методы"
             accesskey="P">предыдущий</a> |</li>
        <li><a href="index.html">Учимся с Python</a> &raquo;</li> 
      </ul>
    </div>

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>14. Коллекции объектов<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h1>
<div class="section" id="index-0">
<span id="id2"></span><h2>14.1. Композиция<a class="headerlink" href="#index-0" title="Ссылка на этот заголовок">¶</a></h2>
<p>К этому моменту вы уже видели несколько примеров композиции. Один из первых примеров &#8212; вызов функции как часть выражения. Другой пример &#8212; вложенные предложения: можно поместить предложение <tt class="docutils literal"><span class="pre">if</span></tt> в цикл <tt class="docutils literal"><span class="pre">while</span></tt>, находящийся внутри <tt class="docutils literal"><span class="pre">if</span></tt>, и так далее.</p>
<p>Познакомившись с композицией, а также со списками и объектами, вы вряд ли удивитесь, узнав, что можно создавать списки объектов. Кроме того, можно создавать объекты, содержащие списки (как атрибуты); списки, содержащие вложенные списки; объекты, содержащие вложенные объекты; и так далее.</p>
<p>В этой и следующей главах мы рассмотрим подобные возможности, работая с объектом <tt class="docutils literal"><span class="pre">Card</span></tt> (англ.: игральная карта).</p>
</div>
<div class="section" id="card">
<span id="index-1"></span><h2>14.2. Объект <tt class="docutils literal"><span class="pre">Card</span></tt><a class="headerlink" href="#card" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если вы незнакомы с игральными картами, то самое время взять в руки колоду. Иначе эта глава будет иметь для вас мало смысла.</p>
<p>В колоде 52 карты, каждая из которых принадлежит одной из четырех мастей и имееет одно из 13 значений. Масти такие: пики (англ.: Spades), червы (англ.: Hearts), бубны (англ.: Diamonds) и трефы (англ.: Clubs). Масти перечислены в порядке убывания старшинства в карточной игре <a class="reference external" href="http://ru.wikipedia.org/wiki/%D0%91%D1%80%D0%B8%D0%B4%D0%B6">бридж</a>. Значения такие: туз (англ.: Ace), 2, 3, 4, 5, 6, 7, 8, 9, 10, валет (англ.: Jack), дама (англ.: Queen) и король (англ.: King). В зависимости от игры, в которую вы играете, туз может быть старше короля или младше двойки.</p>
<p>Определяя класс для представления игральной карты, мы должны определить атрибуты <tt class="docutils literal"><span class="pre">rank</span></tt> (англ.: ранг, звание) и <tt class="docutils literal"><span class="pre">suit</span></tt> (англ.: масть). Какого же типа должны быть эти атрибуты? Как вариант, это могут быть строки, со значениями <tt class="docutils literal"><span class="pre">&quot;Spade&quot;</span></tt> и т.д. для масти, и <tt class="docutils literal"><span class="pre">&quot;Queen&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;King&quot;</span></tt> и т.д. для значений. Проблема такого подхода в том, что будет непросто сравнивать карты, чтобы определить, которая из них старше по значению или масти.</p>
<p>Другой вариант &#8212; использовать целые числа для <strong>кодирования</strong> значений и мастей. Здесь под кодированием имеется в виду не шифрование, которое превращает некоторый текст в нечитаемый секретный код. Под кодированием часто понимают отображение объектов (в широком смысле слова) на коды, например, числовые. Вот пример кодирования:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Spades</span>   <span class="o">--&gt;</span>  <span class="mi">3</span>
<span class="n">Hearts</span>   <span class="o">--&gt;</span>  <span class="mi">2</span>
<span class="n">Diamonds</span> <span class="o">--&gt;</span>  <span class="mi">1</span>
<span class="n">Clubs</span>    <span class="o">--&gt;</span>  <span class="mi">0</span>
</pre></div>
</div>
<p>В данной кодировке масти отображены на целые числа в порядке старшинства мастей, и это дает нам возможность сравнивать масти по старшинству, сравнивая целые числа. Так же просто можно закодировать и значения карт. Туз отобразится на 1, следующие значения отобразятся на соответствующие им числа от 2 до 10, а оставшиеся &#8212; таким образом:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Jack</span>   <span class="o">--&gt;</span>  <span class="mi">11</span>
<span class="n">Queen</span>  <span class="o">--&gt;</span>  <span class="mi">12</span>
<span class="n">King</span>   <span class="o">--&gt;</span>  <span class="mi">13</span>
</pre></div>
</div>
<p>Чтобы показать на рисунках отображение мастей и значений карт на соответствующие коды, мы пользуемся стрелочками. Это не часть программы на Python. Это часть <strong>дизайна программы</strong>, который представляет собой задокументированные решения относительно реализации программы. Разработка дизайна программы (то есть, выработка и запись решений) предшествует написанию программы и облегчает ее создание.</p>
<p>Определение класса <tt class="docutils literal"><span class="pre">Card</span></tt>, представляющего игральную карту, будет выглядеть так:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Card</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suit</span> <span class="o">=</span> <span class="n">suit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="n">rank</span>
</pre></div>
</div>
<p>Мы написали инициализирующий метод, принимающий опциональные аргументы для каждого атрибута.</p>
<p>Для того, чтобы создать объект, представляющий тройку треф, мы напишем:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">three_of_clubs</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Первый аргумент, <tt class="docutils literal"><span class="pre">0</span></tt>, представляет трефовую масть.</p>
</div>
<div class="section" id="str">
<span id="index-2"></span><h2>14.3. Атрибуты класса и метод <tt class="docutils literal"><span class="pre">__str__</span></tt><a class="headerlink" href="#str" title="Ссылка на этот заголовок">¶</a></h2>
<p>Для того, чтобы выводить карты на печать в удобном для чтения виде, отобразим целочисленные коды на строки. Естественный способ сделать это &#8212; с помощью списков. Создадим эти списки как <strong>атрибуты класса</strong> в самом начале определения класса:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Card</span><span class="p">:</span>
    <span class="n">suits</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Clubs&quot;</span><span class="p">,</span> <span class="s">&quot;Diamonds&quot;</span><span class="p">,</span> <span class="s">&quot;Hearts&quot;</span><span class="p">,</span> <span class="s">&quot;Spades&quot;</span><span class="p">]</span>
    <span class="n">ranks</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;narf&quot;</span><span class="p">,</span> <span class="s">&quot;Ace&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">,</span> <span class="s">&quot;4&quot;</span><span class="p">,</span> <span class="s">&quot;5&quot;</span><span class="p">,</span> <span class="s">&quot;6&quot;</span><span class="p">,</span> <span class="s">&quot;7&quot;</span><span class="p">,</span>
                <span class="s">&quot;8&quot;</span><span class="p">,</span> <span class="s">&quot;9&quot;</span><span class="p">,</span> <span class="s">&quot;10&quot;</span><span class="p">,</span> <span class="s">&quot;Jack&quot;</span><span class="p">,</span> <span class="s">&quot;Queen&quot;</span><span class="p">,</span> <span class="s">&quot;King&quot;</span><span class="p">]</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ranks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">]</span> <span class="o">+</span> <span class="s">&quot; of &quot;</span> <span class="o">+</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">suits</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">suit</span><span class="p">])</span>
</pre></div>
</div>
<p>Отныне и впредь многоточие <tt class="docutils literal"><span class="pre">...</span></tt> в нашем коде означает, что мы опустили часть кода для краткости. В данном случае мы опустили инициализирующий метод.</p>
<p>Доступ к атрибутам класса имеют все методы класса. Внутри метода <tt class="docutils literal"><span class="pre">__str__</span></tt> мы используем <tt class="docutils literal"><span class="pre">suits</span></tt> и <tt class="docutils literal"><span class="pre">ranks</span></tt> для того, чтобы отображать числовые значения <tt class="docutils literal"><span class="pre">suit</span></tt> и <tt class="docutils literal"><span class="pre">rank</span></tt> на строки. Например, выражение <tt class="docutils literal"><span class="pre">self.suits[self.suit]</span></tt> использует значение атрибута <tt class="docutils literal"><span class="pre">suit</span></tt> данного объекта <tt class="docutils literal"><span class="pre">self</span></tt> как индекс для получения элемента списка <tt class="docutils literal"><span class="pre">suits</span></tt>. Значение полученного элемента и есть название масти.</p>
<p>Элемент <tt class="docutils literal"><span class="pre">&quot;narf&quot;</span></tt> на первом месте в списке <tt class="docutils literal"><span class="pre">ranks</span></tt> нужен только для того, чтобы занять место с индексом <tt class="docutils literal"><span class="pre">0</span></tt>, который нам не понадобится. Значения, которые имеют смысл для нас, &#8212; от 1 до 13. Без элемента <tt class="docutils literal"><span class="pre">&quot;narf&quot;</span></tt> можно было бы обойтись, если бы мы закодировали туз как 0, 2 как 1, и так далее. Но такой подход сделает наше решение более запутанным и приведет к ошибкам, которых легко избежать, если кодировать 2 как 2, 3 как 3, и так далее.</p>
<p>С имеющимися у нас методами мы можем создать и вывести на печать игральную карту:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">card1</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">card1</span>
<span class="go">Jack of Diamonds</span>
</pre></div>
</div>
<p>Доступ к атрибутам класса <tt class="docutils literal"><span class="pre">Card</span></tt> может быть получен с помощью объекта класса <tt class="docutils literal"><span class="pre">Card</span></tt>, а также с помощью самого класса <tt class="docutils literal"><span class="pre">Card</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">card2</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">card2</span>
<span class="go">3 of Diamonds</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">card2</span><span class="o">.</span><span class="n">suits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Diamonds</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Card</span><span class="o">.</span><span class="n">suites</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Diamonds</span>
</pre></div>
</div>
<p>Изменение атрибута класса немедленно отразится на всех объектах данного класса. Например, если мы решим, что отныне <tt class="docutils literal"><span class="pre">Jack</span> <span class="pre">of</span> <span class="pre">Diamonds</span></tt> будет называться <tt class="docutils literal"><span class="pre">Jack</span> <span class="pre">of</span> <span class="pre">Swirly</span> <span class="pre">Whales</span></tt>, то нам достаточно сделать следующее:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Card</span><span class="o">.</span><span class="n">suits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Swirly Whales&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">card1</span>
<span class="go">Jack of Swirly Whales</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">card2</span>
<span class="go">3 of Swirly Whales</span>
</pre></div>
</div>
<p>Конечно, в данном случае изменение атрибутов класса не имеет смысла. Нам стоит смотреть на атрибуты <tt class="docutils literal"><span class="pre">suits</span></tt> и <tt class="docutils literal"><span class="pre">ranks</span></tt> как на неизменяемые.</p>
</div>
<div class="section" id="id3">
<h2>14.4. Сравнение карт<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h2>
<p>Для примитивных типов существуют операторы сравнения ( <cite>&lt;</cite>, <cite>&gt;</cite>, <cite>==</cite>, и так далле), которые сравнивают значения и определяют, является ли одно значение больше, меньше или равным другому. Для типов, определенных пользователем, можно переопределить поведение этих операторов, написав собственный метод <tt class="docutils literal"><span class="pre">__cmp__</span></tt>. Метод <tt class="docutils literal"><span class="pre">__cmp__</span></tt> принимает два параметра, <tt class="docutils literal"><span class="pre">self</span></tt> и <tt class="docutils literal"><span class="pre">other</span></tt> (англ.: другой), и возвращает 1, если первый объект больше второго, -1, если меньше, и 0, если объекты равны.</p>
<p>Некоторые типы естественным образом упорядочены. Это значит, можно непосредственно сравнить два значения такого типа и узнать, какое из них больше. Например, целые числа или числа с плавающей точкой естественным образом упорядочены. Значения других типов не упорядочены, то есть, не  существует разумного способа определить, что одно значение больше другого. Например, фрукты неупорядочены, и поэтому нельзя сравнивать яблоки с апельсинами.</p>
<p>Множество игральных карт частично упорядочено. Это значит, что иногда можно сравнивать карты, а иногда нет. Например, известно, что тройка треф старше, чем двойка треф, а тройка бубен старше, чем тройка треф. Но что старше: тройка треф или двойка бубен? Первая больше по значению, а у второй старше масть.</p>
<p>Для того, чтобы сделать карты сравнимыми, необходимо решить, что важнее: величина или масть. По правде говоря, выбор можно сделать произвольно. Пусть масть будет важнее. Хотя бы потому, что в новой колоде карты сгруппированы по мастям.</p>
<p>Приняв это решение, мы можем написать метод <tt class="docutils literal"><span class="pre">__cmp__</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="c"># check the suits</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">suit</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">suit</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">suit</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">suit</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c"># suits are the same... check ranks</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c"># ranks are the same... it&#39;s a tie</span>
    <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
<p>При таком сравнении тузы младше двоек.</p>
</div>
<div class="section" id="index-3">
<span id="id4"></span><h2>14.5. Колоды карт<a class="headerlink" href="#index-3" title="Ссылка на этот заголовок">¶</a></h2>
<p>Теперь, когда у нас есть класс <tt class="docutils literal"><span class="pre">Card</span></tt> для представления игральных карт, нам нужен класс для представления колоды карт. Колода, разумеется, состоит из карт, поэтому каждый объект <tt class="docutils literal"><span class="pre">Deck</span></tt> (англ.: колода) будет содержать список карт в качестве атрибута.</p>
<p>Определим класс <tt class="docutils literal"><span class="pre">Deck</span></tt>. Инициализирующий метод создает атрибут <tt class="docutils literal"><span class="pre">cards</span></tt> и помещает в список стандартные 52 карты:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Deck</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cards</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">suit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">14</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Card</span><span class="p">(</span><span class="n">suit</span><span class="p">,</span> <span class="n">rank</span><span class="p">))</span>
</pre></div>
</div>
<p>Простейший способ наполнить колоду &#8212; с помощью вложенного цикла. Внешний цикл перебирает масти от 0 до 3. Внутренний цикл перебирает значения от 1 до 13. Поскольку внешний цикл делает четыре прохода, а внутренний тринадцать, то тело внутреннего цикла, в общей сложности, выполняется 52 раза (четырежды тринадцать). В каждой итерации создается новый экземпляр класса <tt class="docutils literal"><span class="pre">Card</span></tt>, с текущими мастью <tt class="docutils literal"><span class="pre">suit</span></tt> и значением <tt class="docutils literal"><span class="pre">rank</span></tt>, и добавляется в конец списка <tt class="docutils literal"><span class="pre">cards</span></tt>.</p>
<p>Метод <tt class="docutils literal"><span class="pre">append</span></tt> есть у списков, но, конечно же, отсутствует у кортежей.</p>
</div>
<div class="section" id="index-4">
<span id="id5"></span><h2>14.6. Вывод колоды карт на печать<a class="headerlink" href="#index-4" title="Ссылка на этот заголовок">¶</a></h2>
<p>Как обычно, когда мы определяем новый тип объектов, нам требуется метод, который выведет объект на печать. Для печати <tt class="docutils literal"><span class="pre">Deck</span></tt> мы пройдем по всему списку и выведем каждую карту:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Deck</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">print_deck</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">card</span>
</pre></div>
</div>
<p>Вместо метода <tt class="docutils literal"><span class="pre">print_deck</span></tt> мы могли бы написать метод <tt class="docutils literal"><span class="pre">__str__</span></tt> для класса <tt class="docutils literal"><span class="pre">Deck</span></tt>. Преимущество <tt class="docutils literal"><span class="pre">__str__</span></tt> в том, что этот метод более гибок. Он не выводит на печать содержимое объекта, а формирует строковое представление объекта, которое можно использовать как для вывода на печать, так и для других целей.</p>
<p>Вот вариант метода <tt class="docutils literal"><span class="pre">__str__</span></tt>, возвращающий строковое представление объекта <tt class="docutils literal"><span class="pre">Deck</span></tt>. Код код метода располагает карты лесенкой:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Deck</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">)):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&quot; &quot;</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="k">return</span> <span class="n">s</span>
</pre></div>
</div>
<p>Этот код имеет несколько особенностей. Во-первых, вместо перемещения по списку <tt class="docutils literal"><span class="pre">self.cards</span></tt> и последовательных присваиваний карт переменной цикла (как в методе <tt class="docutils literal"><span class="pre">print_deck</span></tt>), здесь мы используем <tt class="docutils literal"><span class="pre">i</span></tt> в качестве переменной цикла и в качестве индекса для доступа к элементам списка.</p>
<p>Во-вторых, мы используем строковый оператор повторения, <tt class="docutils literal"><span class="pre">*</span></tt>, для сдвига каждой карты вправо на один пробел относительно предыдущей. Выражение <tt class="docutils literal"><span class="pre">&quot;</span> <span class="pre">&quot;*i</span></tt> формирует строку из <tt class="docutils literal"><span class="pre">i</span></tt> пробелов.</p>
<p>В-третьих, вместо использования предложения <tt class="docutils literal"><span class="pre">print</span></tt> для вывода карт на печать, мы используем функцию <tt class="docutils literal"><span class="pre">str</span></tt>. Передача объекта функции <tt class="docutils literal"><span class="pre">str</span></tt> в качестве аргумента влечет вызов метода <tt class="docutils literal"><span class="pre">__str__</span></tt> этого объекта.</p>
<p>И в-четвертых, мы используем переменную <tt class="docutils literal"><span class="pre">s</span></tt> как <strong>аккумулятор</strong>. Вначале <tt class="docutils literal"><span class="pre">s</span></tt> пустая строка. Но в каждой итерации новые строки присоединяются к старому значению <tt class="docutils literal"><span class="pre">s</span></tt>, формируя новое значение. Когда цикл заканчивается, <tt class="docutils literal"><span class="pre">s</span></tt> содержит полное строковое представление объекта <tt class="docutils literal"><span class="pre">Deck</span></tt>. Вот как это выглядит:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">deck</span> <span class="o">=</span> <span class="n">Deck</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">deck</span>
<span class="go">Ace of Clubs</span>
<span class="go"> 2 of Clubs</span>
<span class="go">  3 of Clubs</span>
<span class="go">   4 of Clubs</span>
<span class="go">     5 of Clubs</span>
<span class="go">       6 of Clubs</span>
<span class="go">        7 of Clubs</span>
<span class="go">         8 of Clubs</span>
<span class="go">          9 of Clubs</span>
<span class="go">           10 of Clubs</span>
<span class="go">            Jack of Clubs</span>
<span class="go">             Queen of Clubs</span>
<span class="go">              King of Clubs</span>
<span class="go">               Ace of Diamonds</span>
</pre></div>
</div>
<p>И так далее. Хотя результат выводится в 52 строки экрана, это одна длинная последовательность символов, включающая символы перевода строки, содержащаяся в одной строковой переменной Python.</p>
</div>
<div class="section" id="index-5">
<span id="id6"></span><h2>14.7. Тасуем колоду<a class="headerlink" href="#index-5" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если колоду хорошо потасовать, то любая карта с одинаковой вероятностью может оказаться на каком угодно месте в колоде.</p>
<p>Для тасования колоды воспользуемся функцией <tt class="docutils literal"><span class="pre">randrange</span></tt> из модуля <tt class="docutils literal"><span class="pre">random</span></tt>. Эта функция с двумя аргументами, <tt class="docutils literal"><span class="pre">a</span></tt> и <tt class="docutils literal"><span class="pre">b</span></tt>, возвращает случайно выбранное целое число из диапазона <tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">b</span></tt>. Поскольку верхняя граница диапазона, как всегда в Python, исключается, то в качестве второго аргумента можно использовать длину списка. Следующее выражение дает случайный индекс для списка карт:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">))</span>
</pre></div>
</div>
<p>Простой способ перетасовать колоду карт &#8212; пройти по всей колоде, меняя местами текущую карту и случайно выбранную. При этом есть вероятность обменять карту на нее саму, но это нормально. На самом деле, если бы мы исключили такую возможность, то получившийся порядок карт уже не был бы совершенно случайным:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Deck</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">random</span>
        <span class="n">num_cards</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_cards</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">num_cards</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>Вместо того, чтобы предполагать, что в колоде 52 карты, мы получаем реальную длину списка и сохраняем ее в переменной <tt class="docutils literal"><span class="pre">num_cards</span></tt>. Далее, в цикле для каждой карты в колоде мы выбираем случайную карту из тех, что еще не рассмотрели. Затем мы меняем местами текущую карту (<tt class="docutils literal"><span class="pre">i</span></tt>) с выбранной (<tt class="docutils literal"><span class="pre">j</span></tt>). Для того, чтобы поменять карты местами, используется присваивание кортежей:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>14.8. Извлекаем и сдаем карты<a class="headerlink" href="#id7" title="Ссылка на этот заголовок">¶</a></h2>
<p>Другой полезный метод для класса <tt class="docutils literal"><span class="pre">Deck</span></tt> &#8212; метод <tt class="docutils literal"><span class="pre">remove</span></tt>, принимающий карту в качестве аргумента, удаляющий ее из колоды, и возвращающий <tt class="docutils literal"><span class="pre">True</span></tt>, если карта была в колоде, и <tt class="docutils literal"><span class="pre">False</span></tt> в противном случае:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Deck</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">card</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
<p>Оператор <tt class="docutils literal"><span class="pre">in</span></tt> возвращает <tt class="docutils literal"><span class="pre">True</span></tt>, если первый операнд содержится во втором, который может быть списком или кортежем. Если первый операнд является объектом, Python использует метод <tt class="docutils literal"><span class="pre">__cmp__</span></tt> этого объекта для сравнения объекта с элементами списка. Поскольку метод <tt class="docutils literal"><span class="pre">__cmp__</span></tt> класса <tt class="docutils literal"><span class="pre">Card</span></tt> выполняет глубокое сравнение, то метод <tt class="docutils literal"><span class="pre">remove</span></tt> использует глубокое сравнение.</p>
<p>Для того, чтобы сдать карты, нужно извлечь из колоды верхнюю карту. Списочный метод <tt class="docutils literal"><span class="pre">pop</span></tt> представляется подходящим для этой цели:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Deck</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
<p>Поскольку <tt class="docutils literal"><span class="pre">pop</span></tt> удаляет <em>последнюю</em> карту из списка, может показаться, что мы сдаем нижние карты из колоды. Но ведь мы не договаривались, является верхом колоды начало списка или его конец! Так что с нашим методом все в порядке.</p>
<p>Еще одна операция, которая, вероятно, будет полезной &#8212; это логическая функция <cite>is_empty</cite>, возвращающая <cite>True</cite>, если колода пуста:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Deck</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>14.9. Глоссарий<a class="headerlink" href="#id8" title="Ссылка на этот заголовок">¶</a></h2>
<dl class="glossary docutils">
<dt id="term-">аккумулятор</dt>
<dd>Переменная, используемая в цикле для накопления результата, например,
для формирования строки за счет присоединения новых строк, или накопления
суммы за счет прибавления новых слагаемых.</dd>
<dt id="term-1">атрибут класса</dt>
<dd>Переменная, определенная внутри определения класса, но вне определений методов.
Атрибуты класса доступны из любого метода класса, и являются общими для всех
экземпляров этого класса.</dd>
<dt id="term-2">дизайн программы</dt>
<dd>Задокументированные решения относительно реализации программы.</dd>
<dt id="term-3">кодирование</dt>
<dd>Представление одного набора значений с помощью другого набора значений,
путем задания отображения между ними.</dd>
</dl>
</div>
<div class="section" id="id9">
<h2>14.10. Упражнения<a class="headerlink" href="#id9" title="Ссылка на этот заголовок">¶</a></h2>
<ol class="arabic simple">
<li>Измените метод <tt class="docutils literal"><span class="pre">__cmp__</span></tt> класса <tt class="docutils literal"><span class="pre">Card</span></tt> так, чтобы туз стал старше короля.</li>
<li>Напишите метод <tt class="docutils literal"><span class="pre">__cmp__</span></tt> для класса <tt class="docutils literal"><span class="pre">Rectangle</span></tt>, который сравнивает
прямоугольники по их площадям. Протестируйте работу нового метода с помощью
доктестов.</li>
<li>Чтобы перегрузить оператор <tt class="docutils literal"><span class="pre">in</span></tt> для своего класса, нужно написать
метод <tt class="docutils literal"><span class="pre">__contains__(self,</span> <span class="pre">o)</span></tt>. Перегрузите оператор <tt class="docutils literal"><span class="pre">in</span></tt> для <tt class="docutils literal"><span class="pre">Rectangle</span></tt>,
чтобы он определял принадлежность точки (левый операнд) прямоугольнику
(правый операнд). Точка представлена объектом <tt class="docutils literal"><span class="pre">Point</span></tt>. Протестируйте работу
нового метода с помощью доктестов.</li>
<li>Что случится, если левый операнд перегруженного вами оператора <tt class="docutils literal"><span class="pre">in</span></tt> для
<tt class="docutils literal"><span class="pre">Rectangle</span></tt> будет не объектом <tt class="docutils literal"><span class="pre">Point</span></tt>, а объектом другого типа, или целым
числом? Сделайте так, чтобы в этом случае возбуждалось исключение <tt class="docutils literal"><span class="pre">TypeError</span></tt>.</li>
</ol>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Просмотр</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Словарь-указатель"
             >словарь</a></li>
        <li class="right" >
          <a href="ch15.html" title="15. Наследование"
             >следующий</a> |</li>
        <li class="right" >
          <a href="ch13.html" title="13. Методы"
             >предыдущий</a> |</li>
        <li><a href="index.html">Учимся с Python</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="copyright.html">Copyright</a> 2009, 2012, Джеффри Элкнер, Аллен Б. Дауни, Крис Мейерс, Андрей Трофимов.
      При создании использован <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>